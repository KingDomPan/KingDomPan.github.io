<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Scala-Akka | KingDomPan&#39;s Secret Garden</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Actor是什么
Actor引用: actor是以引用的方式暴露给外界的, 内部状态需要被隔离才能Actor模式中获益
一个Actor是一个容器, 包含了状态, 行为, 邮箱, 子Actor, 监管策略
状态: 包含一些变量来反应当前所处的状态, 这些数据是有价值的, 必须被保护起来, 状态不一致是致命的
行为: 每次当一个消息被处理时, 消息会与actor的当前的行为进行匹配. 行为是一个函数,">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala-Akka">
<meta property="og:url" content="http://yoursite.com/2015/09/13/Akka/index.html">
<meta property="og:site_name" content="KingDomPan's Secret Garden">
<meta property="og:description" content="Actor是什么
Actor引用: actor是以引用的方式暴露给外界的, 内部状态需要被隔离才能Actor模式中获益
一个Actor是一个容器, 包含了状态, 行为, 邮箱, 子Actor, 监管策略
状态: 包含一些变量来反应当前所处的状态, 这些数据是有价值的, 必须被保护起来, 状态不一致是致命的
行为: 每次当一个消息被处理时, 消息会与actor的当前的行为进行匹配. 行为是一个函数,">
<meta property="og:updated_time" content="2016-02-04T05:09:36.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scala-Akka">
<meta name="twitter:description" content="Actor是什么
Actor引用: actor是以引用的方式暴露给外界的, 内部状态需要被隔离才能Actor模式中获益
一个Actor是一个容器, 包含了状态, 行为, 邮箱, 子Actor, 监管策略
状态: 包含一些变量来反应当前所处的状态, 这些数据是有价值的, 必须被保护起来, 状态不一致是致命的
行为: 每次当一个消息被处理时, 消息会与actor的当前的行为进行匹配. 行为是一个函数,">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">KingDomPan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">半吊子的Web工程师</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">真的我</a></li>
				        
							<li><a href="/read">读书</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/KingDomPan" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/Akka/" style="font-size: 10px;">Akka</a> <a href="/tags/Data/" style="font-size: 16.67px;">Data</a> <a href="/tags/Fetch/" style="font-size: 10px;">Fetch</a> <a href="/tags/Fiddler/" style="font-size: 10px;">Fiddler</a> <a href="/tags/Finagle/" style="font-size: 10px;">Finagle</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hibernate/" style="font-size: 10px;">Hibernate</a> <a href="/tags/JRebel/" style="font-size: 10px;">JRebel</a> <a href="/tags/JS/" style="font-size: 13.33px;">JS</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Jpa/" style="font-size: 16.67px;">Jpa</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/N-1/" style="font-size: 10px;">N + 1</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/ReactJs/" style="font-size: 13.33px;">ReactJs</a> <a href="/tags/ReactRouter/" style="font-size: 10px;">ReactRouter</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Scala/" style="font-size: 16.67px;">Scala</a> <a href="/tags/Seesion/" style="font-size: 10px;">Seesion</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/Spring-Security-安全验证/" style="font-size: 10px;">Spring Security 安全验证</a> <a href="/tags/V8/" style="font-size: 10px;">V8</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/缓存/" style="font-size: 13.33px;">缓存</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">半吊子的Web工程师</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">KingDomPan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">KingDomPan</h1>
			</hgroup>
			
			<p class="header-subtitle">半吊子的Web工程师</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">真的我</a></li>
		        
					<li><a href="/read">读书</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/KingDomPan" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Akka" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/13/Akka/" class="article-date">
  	<time datetime="2015-09-13T15:54:23.000Z" itemprop="datePublished">2015-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Scala-Akka
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Akka/">Akka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Actor_u662F_u4EC0_u4E48"><a href="#Actor_u662F_u4EC0_u4E48" class="headerlink" title="Actor是什么"></a>Actor是什么</h4><ul>
<li>Actor引用: actor是以引用的方式暴露给外界的, 内部状态需要被隔离才能Actor模式中获益</li>
<li>一个Actor是一个容器, 包含了状态, 行为, 邮箱, 子Actor, 监管策略<ul>
<li>状态: 包含一些变量来反应当前所处的状态, 这些数据是有价值的, 必须被保护起来, 状态不一致是致命的</li>
<li>行为: 每次当一个消息被处理时, 消息会与actor的当前的行为进行匹配. 行为是一个函数, 定义了当前消息所要采取的动作</li>
<li>邮箱: 用来处理消息, 消息是从其他actor发送过来的, 每个actor仅有一个邮箱, 默认按照FIFO处理</li>
<li>子Actor: 每个actor都是一个潜在的监管者, 如果创建子Actor来委托处理任务, 那么默认就会自动监管他们. 子actor维护在actor的上下文中, actor可以访问, 对列表的更改是通过context.actorOf()或者停止context.stop()来实现的, 并且这些更改会立刻生效. 实际的操作是在幕后异步方式完成.</li>
<li>监管策略: 用来处理其子actor错误状况的机制, 错误处理由Akka透明进行, 策略是actor系统组织结构的基础, 所以actor一旦被创建就无法修改</li>
<li>当actor停止时, 失败了并且不能用重启来解决, 停止它自己或者被监管者停止, 它会释放它的资源, 将它邮箱中所有未处理的消息放进系统的”死信邮箱”</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="u76D1_u7BA1_u4E0E_u76D1_u63A7"><a href="#u76D1_u7BA1_u4E0E_u76D1_u63A7" class="headerlink" title="监管与监控"></a>监管与监控</h4><ul>
<li>当一个下属失败了, 会将自己和自己的所有下属挂起, 然后向自己的监管者发送一个提示失败的消息, 监管者有以下四种选择:<ul>
<li>让下属继续执行, 保持下属当前的内部状态</li>
<li>重启下属, 清除下属的内部状态</li>
<li>永久的终止下属</li>
<li>将失败沿着监管树向上传递</li>
<li><strong>一个actor的缺省行为是在重启前终止它的所有下属</strong>, 这种行为可以用Actor类的preRestart来重写; 对所有子Actor的递归重启操作在这个之后执行</li>
</ul>
</li>
<li>每个监管者都配置了一个函数, 将所有可能失败的原因翻译成以上四种选择之一. 这个函数并不将失败actor本身作为输入<ul>
<li>这种方式不是很灵活, 我们会希望对不同的下属有不同的失败处理行为</li>
<li>但是监管树的作用其实是组建一个递归的失败处理机制, 如果试图在一个层次做太多事情, 那么这个层次就会很复杂</li>
<li>akka实现的是一种叫做”父监管”的形式, Actor只能由其它的actor创建, 而顶部的actor是由库来提供的, 每一个创建出来的actor都是由它的父亲所监管</li>
</ul>
</li>
<li>重启的意思<ul>
<li>当actor在处理消息出现失败时, 失败的原因分出以下三类:<ul>
<li>对收到的特定的消息的系统错误, 比如程序错误</li>
<li>处理消息时一些外部资源的临时性失败</li>
<li>actor内部状态崩溃了</li>
</ul>
</li>
<li>以下是重启过程中发生的事件的精确顺序<ul>
<li>actor被挂起</li>
<li>调用旧实例的<code>supervisionStrategy.handleSupervisorFailing</code>方法(缺省实现为挂起所有的子actor)</li>
<li>调用旧实例的<code>preRestart</code>回调(缺省实现为向所有的子actor发送终止请求并调用<code>postStop</code>)</li>
<li>等待所有子actor终止直到<code>preRestart</code>最终结束</li>
<li>调用旧实例的<code>supervisionStrategy.handleSupervisorRestarted</code>方法(缺省实现为向所有剩下的子actor发送重启请求)</li>
<li>再次调用之前提供的actor工厂创建新的actor实例</li>
<li>对新实例调用<code>postRestart</code></li>
<li>恢复运行新的actor</li>
</ul>
</li>
</ul>
</li>
<li>生命周期的监控(One-For-One Strategy vs. All-For-One Strategy)<ul>
<li>OneForOneStrategy</li>
<li>AllForOneStrategy</li>
</ul>
</li>
</ul>
<h4 id="Actor_u5F15_u7528_2C__u8DEF_u5F84_u548C_u5730_u5740"><a href="#Actor_u5F15_u7528_2C__u8DEF_u5F84_u548C_u5730_u5740" class="headerlink" title="Actor引用, 路径和地址"></a>Actor引用, 路径和地址</h4><ul>
<li>actor如何鉴别身份, 在一个可能的分布式系统中如何定位</li>
<li>与actor系统的核心概念相关, 固有的树形监管策略, 跨多个网络节点的actor之间透明的通信</li>
<li><p>Actor引用是什么?</p>
<ul>
<li>Actor引用是<code>ActorRef</code>的子类, 最重要的功能是支持向它所代表的actor发送消息</li>
<li>通过<code>self</code>来访问它的标准本地引用, 在发送给其他actor的消息中也缺省包含这个引用</li>
<li>反过来, actor可以通过<code>sender</code>来访问到当前消息的发送者的引用</li>
<li>根据actor系统的配置, 支持几种不同的actor引用<ul>
<li>纯本地引用使用, 在配置为不使用网络功能的actor系统中. 不能在保证功能的前提下从网络向外传输</li>
<li>支持远程调用, 同一个jvm中的网络功能的actor系统中, 必须包含协议和远程地址信息</li>
<li>本地actor引用有一个子类actor路由. 逻辑结构与第一点一样, 但是发往它的消息会被直接重定向到它的子actor</li>
<li>远程actor引用, 代表可以通过远程通讯访问的actor. 从别的jvm向他们发送消息时, Akka会透明地对消息进行序列化</li>
</ul>
</li>
<li>几个特殊的引用<ul>
<li><code>PromiseActorRef</code>表示一个<code>Promise</code>, 作用是从一个actor返回的响应来完成，它是由 ActorRef.ask 调用来创建的</li>
<li><code>DeadLetterActorRef</code>, <code>DeadLetterActorRef</code>是死信服务的缺省实现, 所有接收方被关闭或不存在的消息都在此被重新路由</li>
<li><code>EmptyLocalActorRef</code>是查找一个不存在的本地actor路径时返回的: 它相当于<code>DeadLetterActorRef</code>, 但是它保有其路径因此可以在网络上发送, 以及与其它相同路径的存活的actor引用进行比较, 其中一些存活的actor引用可能在该actor消失之前得到了.</li>
<li>有一个actor引用但是并不代表任何actor, 只是作为根actor的伪监管者存在</li>
<li>在actor创建设施启动之前运行的第一个日志服务是一个伪actor引用, 它接收日志事件并直接显示到标准输出上; 它就是<code>Logging.StandardOutLogger</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Actor路径是什么?</p>
<ul>
<li>树形结构, 类比文件系统, 也可以通过不同的访问路径得到, 类似符号链接, 这就存在转换放到原始路径</li>
<li><strong>一个actor路径包含一个标识该actor系统的锚点, 之后是各路径元素连接起来, 从根到指定的actor; 路径元素是路径经过的actor的名字, 以”/“分隔</strong></li>
<li>Actor路径锚点: 每一条actor路径都有一个地址组件, 描述如何访问到actor的协议和位置, 之后是从根到actor所经过的树节点上actor的名字<ul>
<li><code>akka://my-system/user/service-a/worker1</code> // 纯本地</li>
<li><code>akka://my-system@serv.example.com:5678/user/service-b</code> // 本地或远程</li>
<li><code>cluster://my-cluster/service-c</code> // 集群(未来扩展)</li>
<li>akka是2.0版本中缺省的远程协议, 主机和端口的理解取决于所使用的传输机制</li>
</ul>
</li>
<li>逻辑路径: 顺着actor的父监管链一直到根的唯一路径称为逻辑actor路径, 这个路径与actor的创建祖先完全吻合, 所以当actor系统的远程调用配置(和配置中路径的地址部分)设置好后它就是完全确定的了</li>
<li>物理Actor路径: 逻辑Actor路径描述一个actor系统内部的功能位置, 基于配置的远程部署意味着一个actor可能在另外一台网络主机上被创建, 即另外一个actor系统中, 这种情况下, 肯定要访问网络. 因此, 每一个actor同时还有一条物理路径, <strong>从实际的actor对象所在的actor系统的根开始的</strong>. 跟其它actor通信时使用物理路径作为发送方引用能够让接收方直接回复到这个actor上, 将路由延迟降到最小</li>
<li>虚拟路径: 未来扩展</li>
</ul>
</li>
<li><p>如何获得Actor引用?</p>
<ul>
<li>通过创建actor: 一个actor系统通常是在根actor上使用<strong>ActorSystem.actorOf创建actor, 然后使用ActorContext.actorOf从创建出的actor中生出actor树来启动的</strong>, 这些方法返回指向创建新的actor的引用, 每个actor都有父, 自己, 子actor的引用</li>
<li>对actor的拜访查找<ul>
<li>通过具体的actor路径来创建actor引用<ul>
<li><code>ActorSystem.actorFor</code>返回一个未验证的本地, 远程或者集群的actor引用, 向这个引用发送消息或试图观察它的存活状态会在actor系统树中从根开始一层一层从父向子actor发送消息, 直到消息到达目标或是出现某种失败</li>
<li><code>ActorContext.actorFor</code>这是在任何一个actor实例中可以用<code>context.actorFor</code>访问的, 所返回的actor引用与ActorSystem的返回值非常类似, 但它的路径查找是从当前actor开始的, 而不是从actor树的根开始. 可以用<code>..</code>路径来访问父actor<ul>
<li><code>context.actorFor(&quot;../brother&quot;) ! msg</code> // 相对路径</li>
<li><code>context.actorFor(&quot;/user/serviceA&quot;) ! msg</code> // 绝对路径</li>
</ul>
</li>
</ul>
</li>
<li>查询逻辑actor数: 使用通配符来进行对多个actor的匹配, 由于匹配的结果不是一个单一的actor引用, 所以类型是<code>ActorSelection</code>, 这个类型不完全支持ActorRef的所有操作. <code>ActorSystem.actorSelection</code>或<code>ActorContext.actorSelection</code></li>
<li><code>context.actorSelection(&quot;../*&quot;) ! msg</code> // 包括当前actor在内的所有兄弟</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="u4E0E_u8FDC_u7A0B_u90E8_u7F72_u4E4B_u95F4_u7684_u4E92_u64CD_u4F5C"><a href="#u4E0E_u8FDC_u7A0B_u90E8_u7F72_u4E4B_u95F4_u7684_u4E92_u64CD_u4F5C" class="headerlink" title="与远程部署之间的互操作"></a>与远程部署之间的互操作</h4><ul>
<li>当一个actor创建一个子actor, actor系统的部署者会决定新的actor是在同一个jvm中或是在其它的节点上<ul>
<li>后者的话actor的创建会通过网络连接来到另一个jvm中进行, 结果是新的actor会进入另一个actor系统</li>
<li>远程系统会将新的actor放在一个专为这种场景所保留的特殊路径下</li>
<li>新的actor的监管者会是一个远程actor引用</li>
<li>这时<code>context.parent</code>（监管者引用）和<code>context.path.parent</code>（actor路径上的父actor）表示的actor是不同的</li>
</ul>
</li>
</ul>
<h4 id="u8DEF_u5F84_u4E2D_u7684_u5730_u5740_u90E8_u5206_u7528_u6765_u505A_u4EC0_u4E48_uFF1F"><a href="#u8DEF_u5F84_u4E2D_u7684_u5730_u5740_u90E8_u5206_u7528_u6765_u505A_u4EC0_u4E48_uFF1F" class="headerlink" title="路径中的地址部分用来做什么？"></a>路径中的地址部分用来做什么？</h4><ul>
<li>在网络上传送actor引用时, 是用它的路径来表示这个actor的</li>
<li>它的路径必须包括能够用来向它所代表的actor发送消息的完整的信息</li>
</ul>
<h4 id="Akka_u4F7F_u7528_u7684_u7279_u6B8A_u8DEF_u5F84"><a href="#Akka_u4F7F_u7528_u7684_u7279_u6B8A_u8DEF_u5F84" class="headerlink" title="Akka使用的特殊路径"></a>Akka使用的特殊路径</h4><ul>
<li><code>/user</code>是所有由用户创建的顶级actor的监管者, 用<code>ActorSystem.actorOf</code>创建的actor在其下一个层次</li>
<li><code>/system</code>是所有由系统创建的顶级actor(如日志监听器或由配置指定在actor系统启动时自动部署的actor)的监管者</li>
<li><code>/deadLetters</code>是死信actor, 所有发往已经终止或不存在的actor的消息会被送到这里</li>
<li><code>/temp</code>是所有系统创建的短时actor(i.e.那些用在ActorRef.ask的实现中的actor)的监管者.</li>
<li><code>/remote</code>是一个人造的路径, 用来存放所有其监管者是远程actor引用的actor</li>
</ul>
<h4 id="u4F4D_u7F6E_u900F_u660E_u6027"><a href="#u4F4D_u7F6E_u900F_u660E_u6027" class="headerlink" title="位置透明性"></a>位置透明性</h4><ul>
<li>天生的分布式<ul>
<li>akka中所有的消息都是被设计成分布式的, 所有actor都使用消息进行通信, 所有的操作都是异步的</li>
<li>要实现的优化是<strong>从远程到本地的优化</strong></li>
</ul>
</li>
<li>透明性会被破坏的方式<ul>
<li>分布式的设计对可以做的事情做了一些限制, akka所满足的在使用akka的应用程序中也并不一定被满足</li>
<li>最明显的是一条是网络上发送的所有消息都是可序列化的</li>
<li>不那么明显的是这也包括在远程节点上创建actor时用作actor工厂的闭包(i.e. 在Props里)</li>
</ul>
</li>
<li>远程调用如何使用？<ul>
<li>没有为远程调用设计的api, 完全靠配置来驱动, 配置文件中指定远程部署的actor子树, 可以不修改代码而进行扩展</li>
<li>唯一允许编程来影响远程部署的是<code>Props</code>中包含的一个属性, 这个属性可能被设计为一个特定的<code>Deploy</code>实例</li>
</ul>
</li>
<li>使用路由来进行垂直扩展的标记点<ul>
<li>可以在集群中的不同节点上运行一个actor系统的不同部分</li>
<li>还可以通过并行增加actor子树的方法来垂直扩展到多个cpu核上</li>
</ul>
</li>
</ul>
<h4 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h4><ul>
<li>ActorSystem是配置消息的唯一消费者, 构建一个ActorSystem系统的时候, 会传入一个Config对象, 不传递的话使用的是ConfigFactory.load()</li>
<li>使用的是typesafe Config库</li>
<li>读取classpath下的application.conf, application.json, application.properties</li>
<li>合并classpath根目录下的reference.conf来组成其内部的默认配置值</li>
<li><p>ConfigFactory.load()会合并classpath中所有匹配名称的资源</p>
<ul>
<li><p>配置树中区分actor系统</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">myapp1 &#123;</span><br><span class="line">  akka.loglevel = <span class="type">WARNING</span></span><br><span class="line">  my.own.setting = <span class="number">43</span></span><br><span class="line">&#125;</span><br><span class="line">myapp2 &#123;</span><br><span class="line">  akka.loglevel = <span class="type">ERROR</span></span><br><span class="line">  app2.setting = <span class="string">"appname"</span></span><br><span class="line">&#125;</span><br><span class="line">my.own.setting = <span class="number">42</span></span><br><span class="line">my.other.setting = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h5 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h5><ul>
<li>Props, 是一个用来在创建actor时指定选项的配置类</li>
<li>未处理的消息行为, 默认实现是向actor系统的事件流中发布一条akka.actor.UnhandledMessage(message, sender, recipient)</li>
<li>self代表本身的ActorRef</li>
<li>sender收到消息的发送者</li>
<li>supervisorStrategy, 对子actor的监管策略</li>
<li>context 暴露actor和当前消息的上下文信息<ul>
<li>actorOf</li>
<li>所属的系统</li>
<li>父监管者</li>
<li>生命周期监控<ul>
<li>preStart 启动后会立即被执行</li>
<li>preRestart 在处理一个消息的时候抛出异常, 那么将被重启</li>
<li>postRestart</li>
<li>postStop 终止, 保证消息队列被禁止后才运行, 之后发送给该actor的消息都被重定向到<strong>deadLetters</strong></li>
</ul>
</li>
<li>hotswap行为栈(Become/Unbecome)</li>
</ul>
</li>
<li>使用DeathWatch进行生命周期的监控, 将自己注册为某个停止的actor的Terminated消息的接收者<ul>
<li>case terminated(‘child’)</li>
</ul>
</li>
<li>! fire and forget 异步发送一个消息并立即返回 也称为tell</li>
<li>? 异步发送一条消息并返回一个Future对象, 代表一个可能的回应, 也称为ask, 作为一种模式使用</li>
<li>sender, 如果不是从actor发送的, 那么sender的默认实例是deadLetters</li>
<li>消息转发, forward, 当实现功能类似路由器, 负载均衡器, 备份等的actor会很有用</li>
</ul>
<h5 id="TypedActor"><a href="#TypedActor" class="headerlink" title="TypedActor"></a>TypedActor</h5><h5 id="EventBus__u4E8B_u4EF6_u603B_u7EBF_2C__u4E8B_u4EF6_u6D41_2C__u4E8B_u4EF6_u5904_u7406_u5668_2C_system-event"><a href="#EventBus__u4E8B_u4EF6_u603B_u7EBF_2C__u4E8B_u4EF6_u6D41_2C__u4E8B_u4EF6_u5904_u7406_u5668_2C_system-event" class="headerlink" title="EventBus 事件总线, 事件流, 事件处理器, system.event"></a>EventBus 事件总线, 事件流, 事件处理器, system.event</h5><h5 id="u5B9A_u65F6_u5668"><a href="#u5B9A_u65F6_u5668" class="headerlink" title="定时器"></a>定时器</h5><ul>
<li>scheduler返回一个akka.actor.Scheduler实例, 这个实例在每个System里面是唯一的, 用来指定一段时间后发生的行为</li>
<li>定时任务是使用ActorSystem.MessageDispatcher执行的</li>
<li>向actor发送消息或者执行任务的代码, 返回一个Cancellable类型的对象, 使用cancel来取消定时任务的执行, 不会终止正在进行的任务<ul>
<li><code>system.scheduler.scheduleOnce(50 milliseconds, testActor, &quot;foo&quot;)</code> 计划在50mm后向testActor发送foo消息</li>
<li><code>system.scheduler.scheduleOnce(50 milliseconds) { testActor ! System.currentTimeMills }</code> 计划50mm后发送当前时间给testActor</li>
<li><code>val cancellable = system.scheduler.scheduleOnce(0 milliseconds, 50 milliseconds, testActor, &quot;panqd&quot;)</code> 计划0mm后每隔50mm发送panqd给testActor</li>
</ul>
</li>
</ul>
<h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><ul>
<li>用来获取某个并发操作的结果的数据结构, 这个操作通常是由Actor执行或者由Dispatcher直接执行的, 这个结果可以同步或者异步的方式访问</li>
<li>为了运行回调, 需要一个ExecutionContext, 与java.util.concurrent.Executor<ul>
<li><code>implicit val ec = ExecutionContext.fromExecutorService(这边是你自己定义的ExecutorSerivce)</code></li>
<li><code>val f = Promise successful &quot;panqd&quot;</code></li>
<li><code>es.shutdown</code></li>
</ul>
</li>
<li>阻塞方式的调用<ul>
<li><code>actor ? msg</code></li>
<li><code>Await.result(future, timeout.duration).asInstanceOf[String]</code> // Await.result 或者 Await.ready</li>
</ul>
</li>
<li>使用非阻塞时, 类型转换要用mapTo<ul>
<li><code>val future: Future[String] = ask(actor, msg).mapTo[String]</code></li>
</ul>
</li>
<li>函数式Future<ul>
<li>map</li>
<li>sequence</li>
<li>traverse</li>
<li>fold</li>
<li>reduce</li>
<li>回调<ul>
<li>onComplete</li>
<li>onSuccess</li>
<li>onFailure</li>
</ul>
</li>
<li>定义次序 andThen 会为指定的回调创建一个新的Future, 新的Future拥有相同的结果</li>
<li>fallbackTo 将2个Futures合并成一个新的Future, 如果第一个失败了, 它将持有第二个Future的成功值</li>
</ul>
</li>
</ul>
<h5 id="u6570_u636E_u6D41_u5E76_u53D1"><a href="#u6570_u636E_u6D41_u5E76_u53D1" class="headerlink" title="数据流并发"></a>数据流并发</h5><ul>
<li>类似函数输入输出, 具有行为一致性</li>
</ul>
<h5 id="u5BB9_u9519"><a href="#u5BB9_u9519" class="headerlink" title="容错"></a>容错</h5><ul>
<li>策略匹配 PartialFunction[Throwable, Directive]</li>
<li>缺省的监管机制<ul>
<li>如果定义的监管机制没有覆盖抛出的异常,就使用上溯机制</li>
<li>如果某个actor没有定义监管机制, 下列异常将被缺省的处理<ul>
<li>ActorInitializationException 将终止出错的actor</li>
<li>ActorKilledException将终止除错的actor</li>
<li>Exception 将重出错的子actor</li>
<li>其他的Throwable将被上溯传给父actor</li>
</ul>
</li>
<li>如果异常一直被上溯到根监管者, 在那儿也会用上述的缺省方式进行处理</li>
<li>监管者默认处理的Exception不会被处理而是会被上述到顶级监管者, 默认的处理策略会杀死所有的子actor, 这样造成出错误的actor都会被杀死. <strong>覆盖preRestart</strong></li>
</ul>
</li>
</ul>
<h5 id="u6D3E_u53D1_u5668"><a href="#u6D3E_u53D1_u5668" class="headerlink" title="派发器"></a>派发器</h5><ul>
<li>在没有为actor做配置的情况下, 一个system将有一个默认的派发器, 这个派发器是fork-join-executor的Dispatcher, 在大多数情况下拥有非常良好的性能</li>
<li>为acotr设置派发器, 需要做2件事<ul>
<li>Props[Actor].withDispatcher(“myDispatcher”)</li>
</ul>
</li>
<li>派发器的类型<ul>
<li>Dispatcher<ul>
<li>可共享性: 无限制</li>
<li>邮箱: 任何, 为每一个actor创建一个</li>
<li>使用场景: 默认派发器, Bulkheading</li>
<li>底层: java.util.concurrent.ExecutorService</li>
</ul>
</li>
<li>PinnedDispacther<ul>
<li>共享性: 无</li>
<li>邮箱: 同上</li>
<li>使用场景: Bulkheading</li>
<li>底层: akka.dispatch.ThreadPoolExecutorConfigurator, 缺省为一个thread-pool-executor</li>
</ul>
</li>
<li>BalancingDispatcher<ul>
<li>共享性: 仅对同一类型的actor共享</li>
<li>邮箱: 任何, 为所有的actor创建一个</li>
<li>使用场景: Work-sharing</li>
<li>底层使用: 指定使用”executor”使用”fork-join-executor”, “thread-pool-executor”或akka.dispatcher.ExecutorServiceConfigurator的全称</li>
</ul>
</li>
<li>CallingThreadDispatcher<ul>
<li>共享性: 无限制</li>
<li>邮箱: 任何, 每actor每线程创建一个(需要时)</li>
<li>使用场景: 测试</li>
<li>底层使用: 调用线程</li>
</ul>
</li>
</ul>
</li>
<li>邮箱的类型<ul>
<li>UnboundedMailbox<ul>
<li>底层: java.util.concurrent.ConcurrentLinkedQueue</li>
<li>不阻塞, 不绑定</li>
</ul>
</li>
<li>BoundedMailbox<ul>
<li>底层: java.util.concurrent.LinkedBlockingQueue</li>
<li>阻塞, 绑定</li>
</ul>
</li>
<li>UnboundedPriorityMailbox<ul>
<li>底层: java.util.concurrent.PriorityBlockingQueue</li>
<li>阻塞, 不绑定</li>
</ul>
</li>
<li>BoundedPriorityMailbox<ul>
<li>底层: java.util.PriorityBlockingQueue wrapped in an akka.util.BoundedBlockingQueue</li>
<li>阻塞, 绑定</li>
</ul>
</li>
<li>持久邮箱</li>
</ul>
</li>
</ul>
<h5 id="u8DEF_u7531"><a href="#u8DEF_u7531" class="headerlink" title="路由"></a>路由</h5><ul>
<li>路由actor是将收到的消息路由到目的actor的actor</li>
<li>路由actor将消息发送给它所管理的称为’routees’的actor</li>
<li>子类的actor<ul>
<li>akka.routing.RoundRobinRouter: actor均摊分配处理消息</li>
<li>akka.routing.RandomRouter: actor被随机处理</li>
<li>akka.routing.SmallestMailboxRouter: 选择未挂起的邮箱中消息数最少的routee</li>
<li>akka.routing.BroadcastRouter: 将消息转发给所有routees</li>
<li>akka.routing.ScatterGatherFirstCompletedRouter: 将消息作为一个future发送给所有的routees. 然后等待回送的第一个结果</li>
</ul>
</li>
<li>远程部署Routee<ul>
<li>除了将查找到的远程actor作为routee, 你也可以让路由actor将自己创建的子actor部署到一组远程主机上, 这是以round-robin方式执行的<ul>
<li>包含akka-remote模块</li>
<li>配置文件中RemoteRouterConfig中, 并附上作为部署目标的结点的远程地</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/09/14/Finagle/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Scala-Finagle
        
      </div>
    </a>
  
  
    <a href="/2015/09/12/Scala-Language/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Scala-Language</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Akka" data-title="Scala-Akka" data-url="http://yoursite.com/2015/09/13/Akka/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"KingDomPan"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 KingDomPan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>